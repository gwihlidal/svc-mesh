// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SVCMESH_SERVICE_MESH_SCHEMA_H_
#define FLATBUFFERS_GENERATED_SVCMESH_SERVICE_MESH_SCHEMA_H_

#include "flatbuffers/flatbuffers.h"

namespace service {
namespace mesh {
namespace schema {

struct Animation;

struct MeshStream;

struct MeshMaterial;

struct MeshPart;

struct Mesh;

struct Manifest;

enum StreamFormat {
  StreamFormat_Invalid = 0,
  StreamFormat_Float = 1,
  StreamFormat_Vector4 = 2,
  StreamFormat_Vector3 = 3,
  StreamFormat_Vector2 = 4,
  StreamFormat_Int = 5,
  StreamFormat_Int3 = 6,
  StreamFormat_MIN = StreamFormat_Invalid,
  StreamFormat_MAX = StreamFormat_Int3
};

inline const StreamFormat (&EnumValuesStreamFormat())[7] {
  static const StreamFormat values[] = {
    StreamFormat_Invalid,
    StreamFormat_Float,
    StreamFormat_Vector4,
    StreamFormat_Vector3,
    StreamFormat_Vector2,
    StreamFormat_Int,
    StreamFormat_Int3
  };
  return values;
}

inline const char * const *EnumNamesStreamFormat() {
  static const char * const names[] = {
    "Invalid",
    "Float",
    "Vector4",
    "Vector3",
    "Vector2",
    "Int",
    "Int3",
    nullptr
  };
  return names;
}

inline const char *EnumNameStreamFormat(StreamFormat e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesStreamFormat()[index];
}

enum StreamType {
  StreamType_Positions = 0,
  StreamType_Normals = 1,
  StreamType_Tangents = 2,
  StreamType_Bitangents = 3,
  StreamType_TextureCoordinates = 4,
  StreamType_Colors = 5,
  StreamType_Indices = 6,
  StreamType_MIN = StreamType_Positions,
  StreamType_MAX = StreamType_Indices
};

inline const StreamType (&EnumValuesStreamType())[7] {
  static const StreamType values[] = {
    StreamType_Positions,
    StreamType_Normals,
    StreamType_Tangents,
    StreamType_Bitangents,
    StreamType_TextureCoordinates,
    StreamType_Colors,
    StreamType_Indices
  };
  return values;
}

inline const char * const *EnumNamesStreamType() {
  static const char * const names[] = {
    "Positions",
    "Normals",
    "Tangents",
    "Bitangents",
    "TextureCoordinates",
    "Colors",
    "Indices",
    nullptr
  };
  return names;
}

inline const char *EnumNameStreamType(StreamType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesStreamType()[index];
}

enum AnimationType {
  AnimationType_None = 0,
  AnimationType_Rigid = 1,
  AnimationType_Skinned = 2,
  AnimationType_MIN = AnimationType_None,
  AnimationType_MAX = AnimationType_Skinned
};

inline const AnimationType (&EnumValuesAnimationType())[3] {
  static const AnimationType values[] = {
    AnimationType_None,
    AnimationType_Rigid,
    AnimationType_Skinned
  };
  return values;
}

inline const char * const *EnumNamesAnimationType() {
  static const char * const names[] = {
    "None",
    "Rigid",
    "Skinned",
    nullptr
  };
  return names;
}

inline const char *EnumNameAnimationType(AnimationType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesAnimationType()[index];
}

struct Animation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AnimationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AnimationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimationBuilder &operator=(const AnimationBuilder &);
  flatbuffers::Offset<Animation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Animation>(end);
    return o;
  }
};

inline flatbuffers::Offset<Animation> CreateAnimation(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AnimationBuilder builder_(_fbb);
  return builder_.Finish();
}

struct MeshStream FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_FORMAT = 6,
    VT_ELEMENTS = 8,
    VT_DATA = 10
  };
  StreamType type() const {
    return static_cast<StreamType>(GetField<int8_t>(VT_TYPE, 0));
  }
  StreamFormat format() const {
    return static_cast<StreamFormat>(GetField<int8_t>(VT_FORMAT, 0));
  }
  uint64_t elements() const {
    return GetField<uint64_t>(VT_ELEMENTS, 0);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<int8_t>(verifier, VT_FORMAT) &&
           VerifyField<uint64_t>(verifier, VT_ELEMENTS) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct MeshStreamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(StreamType type) {
    fbb_.AddElement<int8_t>(MeshStream::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_format(StreamFormat format) {
    fbb_.AddElement<int8_t>(MeshStream::VT_FORMAT, static_cast<int8_t>(format), 0);
  }
  void add_elements(uint64_t elements) {
    fbb_.AddElement<uint64_t>(MeshStream::VT_ELEMENTS, elements, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(MeshStream::VT_DATA, data);
  }
  explicit MeshStreamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MeshStreamBuilder &operator=(const MeshStreamBuilder &);
  flatbuffers::Offset<MeshStream> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MeshStream>(end);
    return o;
  }
};

inline flatbuffers::Offset<MeshStream> CreateMeshStream(
    flatbuffers::FlatBufferBuilder &_fbb,
    StreamType type = StreamType_Positions,
    StreamFormat format = StreamFormat_Invalid,
    uint64_t elements = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  MeshStreamBuilder builder_(_fbb);
  builder_.add_elements(elements);
  builder_.add_data(data);
  builder_.add_format(format);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<MeshStream> CreateMeshStreamDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    StreamType type = StreamType_Positions,
    StreamFormat format = StreamFormat_Invalid,
    uint64_t elements = 0,
    const std::vector<uint8_t> *data = nullptr) {
  return service::mesh::schema::CreateMeshStream(
      _fbb,
      type,
      format,
      elements,
      data ? _fbb.CreateVector<uint8_t>(*data) : 0);
}

struct MeshMaterial FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_MATERIAL = 6,
    VT_ALBEDO_TINT = 8,
    VT_ROUGHNESS = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *material() const {
    return GetPointer<const flatbuffers::String *>(VT_MATERIAL);
  }
  const flatbuffers::Vector<float> *albedo_tint() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_ALBEDO_TINT);
  }
  float roughness() const {
    return GetField<float>(VT_ROUGHNESS, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_MATERIAL) &&
           verifier.VerifyString(material()) &&
           VerifyOffset(verifier, VT_ALBEDO_TINT) &&
           verifier.VerifyVector(albedo_tint()) &&
           VerifyField<float>(verifier, VT_ROUGHNESS) &&
           verifier.EndTable();
  }
};

struct MeshMaterialBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(MeshMaterial::VT_NAME, name);
  }
  void add_material(flatbuffers::Offset<flatbuffers::String> material) {
    fbb_.AddOffset(MeshMaterial::VT_MATERIAL, material);
  }
  void add_albedo_tint(flatbuffers::Offset<flatbuffers::Vector<float>> albedo_tint) {
    fbb_.AddOffset(MeshMaterial::VT_ALBEDO_TINT, albedo_tint);
  }
  void add_roughness(float roughness) {
    fbb_.AddElement<float>(MeshMaterial::VT_ROUGHNESS, roughness, 0.0f);
  }
  explicit MeshMaterialBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MeshMaterialBuilder &operator=(const MeshMaterialBuilder &);
  flatbuffers::Offset<MeshMaterial> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MeshMaterial>(end);
    return o;
  }
};

inline flatbuffers::Offset<MeshMaterial> CreateMeshMaterial(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> material = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> albedo_tint = 0,
    float roughness = 0.0f) {
  MeshMaterialBuilder builder_(_fbb);
  builder_.add_roughness(roughness);
  builder_.add_albedo_tint(albedo_tint);
  builder_.add_material(material);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<MeshMaterial> CreateMeshMaterialDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *material = nullptr,
    const std::vector<float> *albedo_tint = nullptr,
    float roughness = 0.0f) {
  return service::mesh::schema::CreateMeshMaterial(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      material ? _fbb.CreateString(material) : 0,
      albedo_tint ? _fbb.CreateVector<float>(*albedo_tint) : 0,
      roughness);
}

struct MeshPart FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_INDEX_START = 4,
    VT_INDEX_COUNT = 6,
    VT_MATERIAL_INDEX = 8,
    VT_NODE_INDEX = 10,
    VT_BASE_TRANSFORM = 12,
    VT_NAME = 14,
    VT_ANIMATION_TYPE = 16
  };
  uint32_t index_start() const {
    return GetField<uint32_t>(VT_INDEX_START, 0);
  }
  uint32_t index_count() const {
    return GetField<uint32_t>(VT_INDEX_COUNT, 0);
  }
  int32_t material_index() const {
    return GetField<int32_t>(VT_MATERIAL_INDEX, 0);
  }
  int32_t node_index() const {
    return GetField<int32_t>(VT_NODE_INDEX, 0);
  }
  const flatbuffers::Vector<float> *base_transform() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BASE_TRANSFORM);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  AnimationType animation_type() const {
    return static_cast<AnimationType>(GetField<int8_t>(VT_ANIMATION_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_INDEX_START) &&
           VerifyField<uint32_t>(verifier, VT_INDEX_COUNT) &&
           VerifyField<int32_t>(verifier, VT_MATERIAL_INDEX) &&
           VerifyField<int32_t>(verifier, VT_NODE_INDEX) &&
           VerifyOffset(verifier, VT_BASE_TRANSFORM) &&
           verifier.VerifyVector(base_transform()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int8_t>(verifier, VT_ANIMATION_TYPE) &&
           verifier.EndTable();
  }
};

struct MeshPartBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_index_start(uint32_t index_start) {
    fbb_.AddElement<uint32_t>(MeshPart::VT_INDEX_START, index_start, 0);
  }
  void add_index_count(uint32_t index_count) {
    fbb_.AddElement<uint32_t>(MeshPart::VT_INDEX_COUNT, index_count, 0);
  }
  void add_material_index(int32_t material_index) {
    fbb_.AddElement<int32_t>(MeshPart::VT_MATERIAL_INDEX, material_index, 0);
  }
  void add_node_index(int32_t node_index) {
    fbb_.AddElement<int32_t>(MeshPart::VT_NODE_INDEX, node_index, 0);
  }
  void add_base_transform(flatbuffers::Offset<flatbuffers::Vector<float>> base_transform) {
    fbb_.AddOffset(MeshPart::VT_BASE_TRANSFORM, base_transform);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(MeshPart::VT_NAME, name);
  }
  void add_animation_type(AnimationType animation_type) {
    fbb_.AddElement<int8_t>(MeshPart::VT_ANIMATION_TYPE, static_cast<int8_t>(animation_type), 0);
  }
  explicit MeshPartBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MeshPartBuilder &operator=(const MeshPartBuilder &);
  flatbuffers::Offset<MeshPart> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MeshPart>(end);
    return o;
  }
};

inline flatbuffers::Offset<MeshPart> CreateMeshPart(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t index_start = 0,
    uint32_t index_count = 0,
    int32_t material_index = 0,
    int32_t node_index = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> base_transform = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    AnimationType animation_type = AnimationType_None) {
  MeshPartBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_base_transform(base_transform);
  builder_.add_node_index(node_index);
  builder_.add_material_index(material_index);
  builder_.add_index_count(index_count);
  builder_.add_index_start(index_start);
  builder_.add_animation_type(animation_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<MeshPart> CreateMeshPartDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t index_start = 0,
    uint32_t index_count = 0,
    int32_t material_index = 0,
    int32_t node_index = 0,
    const std::vector<float> *base_transform = nullptr,
    const char *name = nullptr,
    AnimationType animation_type = AnimationType_None) {
  return service::mesh::schema::CreateMeshPart(
      _fbb,
      index_start,
      index_count,
      material_index,
      node_index,
      base_transform ? _fbb.CreateVector<float>(*base_transform) : 0,
      name ? _fbb.CreateString(name) : 0,
      animation_type);
}

struct Mesh FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_IDENTITY = 6,
    VT_PARTS = 8,
    VT_MATERIALS = 10,
    VT_STREAMS = 12,
    VT_SKINNING_DATA = 14,
    VT_ANIMATIONS = 16,
    VT_BOUNDING_MIN = 18,
    VT_BOUNDING_MAX = 20
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *identity() const {
    return GetPointer<const flatbuffers::String *>(VT_IDENTITY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<MeshPart>> *parts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MeshPart>> *>(VT_PARTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<MeshMaterial>> *materials() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MeshMaterial>> *>(VT_MATERIALS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<MeshStream>> *streams() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MeshStream>> *>(VT_STREAMS);
  }
  const flatbuffers::Vector<uint8_t> *skinning_data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SKINNING_DATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Animation>> *animations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Animation>> *>(VT_ANIMATIONS);
  }
  const flatbuffers::Vector<float> *bounding_min() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BOUNDING_MIN);
  }
  const flatbuffers::Vector<float> *bounding_max() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BOUNDING_MAX);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_IDENTITY) &&
           verifier.VerifyString(identity()) &&
           VerifyOffset(verifier, VT_PARTS) &&
           verifier.VerifyVector(parts()) &&
           verifier.VerifyVectorOfTables(parts()) &&
           VerifyOffset(verifier, VT_MATERIALS) &&
           verifier.VerifyVector(materials()) &&
           verifier.VerifyVectorOfTables(materials()) &&
           VerifyOffset(verifier, VT_STREAMS) &&
           verifier.VerifyVector(streams()) &&
           verifier.VerifyVectorOfTables(streams()) &&
           VerifyOffset(verifier, VT_SKINNING_DATA) &&
           verifier.VerifyVector(skinning_data()) &&
           VerifyOffset(verifier, VT_ANIMATIONS) &&
           verifier.VerifyVector(animations()) &&
           verifier.VerifyVectorOfTables(animations()) &&
           VerifyOffset(verifier, VT_BOUNDING_MIN) &&
           verifier.VerifyVector(bounding_min()) &&
           VerifyOffset(verifier, VT_BOUNDING_MAX) &&
           verifier.VerifyVector(bounding_max()) &&
           verifier.EndTable();
  }
};

struct MeshBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Mesh::VT_NAME, name);
  }
  void add_identity(flatbuffers::Offset<flatbuffers::String> identity) {
    fbb_.AddOffset(Mesh::VT_IDENTITY, identity);
  }
  void add_parts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MeshPart>>> parts) {
    fbb_.AddOffset(Mesh::VT_PARTS, parts);
  }
  void add_materials(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MeshMaterial>>> materials) {
    fbb_.AddOffset(Mesh::VT_MATERIALS, materials);
  }
  void add_streams(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MeshStream>>> streams) {
    fbb_.AddOffset(Mesh::VT_STREAMS, streams);
  }
  void add_skinning_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> skinning_data) {
    fbb_.AddOffset(Mesh::VT_SKINNING_DATA, skinning_data);
  }
  void add_animations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Animation>>> animations) {
    fbb_.AddOffset(Mesh::VT_ANIMATIONS, animations);
  }
  void add_bounding_min(flatbuffers::Offset<flatbuffers::Vector<float>> bounding_min) {
    fbb_.AddOffset(Mesh::VT_BOUNDING_MIN, bounding_min);
  }
  void add_bounding_max(flatbuffers::Offset<flatbuffers::Vector<float>> bounding_max) {
    fbb_.AddOffset(Mesh::VT_BOUNDING_MAX, bounding_max);
  }
  explicit MeshBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MeshBuilder &operator=(const MeshBuilder &);
  flatbuffers::Offset<Mesh> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Mesh>(end);
    return o;
  }
};

inline flatbuffers::Offset<Mesh> CreateMesh(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> identity = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MeshPart>>> parts = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MeshMaterial>>> materials = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MeshStream>>> streams = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> skinning_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Animation>>> animations = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> bounding_min = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> bounding_max = 0) {
  MeshBuilder builder_(_fbb);
  builder_.add_bounding_max(bounding_max);
  builder_.add_bounding_min(bounding_min);
  builder_.add_animations(animations);
  builder_.add_skinning_data(skinning_data);
  builder_.add_streams(streams);
  builder_.add_materials(materials);
  builder_.add_parts(parts);
  builder_.add_identity(identity);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Mesh> CreateMeshDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *identity = nullptr,
    const std::vector<flatbuffers::Offset<MeshPart>> *parts = nullptr,
    const std::vector<flatbuffers::Offset<MeshMaterial>> *materials = nullptr,
    const std::vector<flatbuffers::Offset<MeshStream>> *streams = nullptr,
    const std::vector<uint8_t> *skinning_data = nullptr,
    const std::vector<flatbuffers::Offset<Animation>> *animations = nullptr,
    const std::vector<float> *bounding_min = nullptr,
    const std::vector<float> *bounding_max = nullptr) {
  return service::mesh::schema::CreateMesh(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      identity ? _fbb.CreateString(identity) : 0,
      parts ? _fbb.CreateVector<flatbuffers::Offset<MeshPart>>(*parts) : 0,
      materials ? _fbb.CreateVector<flatbuffers::Offset<MeshMaterial>>(*materials) : 0,
      streams ? _fbb.CreateVector<flatbuffers::Offset<MeshStream>>(*streams) : 0,
      skinning_data ? _fbb.CreateVector<uint8_t>(*skinning_data) : 0,
      animations ? _fbb.CreateVector<flatbuffers::Offset<Animation>>(*animations) : 0,
      bounding_min ? _fbb.CreateVector<float>(*bounding_min) : 0,
      bounding_max ? _fbb.CreateVector<float>(*bounding_max) : 0);
}

struct Manifest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MESHES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Mesh>> *meshes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Mesh>> *>(VT_MESHES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESHES) &&
           verifier.VerifyVector(meshes()) &&
           verifier.VerifyVectorOfTables(meshes()) &&
           verifier.EndTable();
  }
};

struct ManifestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_meshes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Mesh>>> meshes) {
    fbb_.AddOffset(Manifest::VT_MESHES, meshes);
  }
  explicit ManifestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ManifestBuilder &operator=(const ManifestBuilder &);
  flatbuffers::Offset<Manifest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Manifest>(end);
    return o;
  }
};

inline flatbuffers::Offset<Manifest> CreateManifest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Mesh>>> meshes = 0) {
  ManifestBuilder builder_(_fbb);
  builder_.add_meshes(meshes);
  return builder_.Finish();
}

inline flatbuffers::Offset<Manifest> CreateManifestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Mesh>> *meshes = nullptr) {
  return service::mesh::schema::CreateManifest(
      _fbb,
      meshes ? _fbb.CreateVector<flatbuffers::Offset<Mesh>>(*meshes) : 0);
}

inline const service::mesh::schema::Manifest *GetManifest(const void *buf) {
  return flatbuffers::GetRoot<service::mesh::schema::Manifest>(buf);
}

inline const service::mesh::schema::Manifest *GetSizePrefixedManifest(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<service::mesh::schema::Manifest>(buf);
}

inline bool VerifyManifestBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<service::mesh::schema::Manifest>(nullptr);
}

inline bool VerifySizePrefixedManifestBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<service::mesh::schema::Manifest>(nullptr);
}

inline void FinishManifestBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<service::mesh::schema::Manifest> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedManifestBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<service::mesh::schema::Manifest> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace schema
}  // namespace mesh
}  // namespace service

#endif  // FLATBUFFERS_GENERATED_SVCMESH_SERVICE_MESH_SCHEMA_H_
